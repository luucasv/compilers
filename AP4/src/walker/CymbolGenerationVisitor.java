package walker;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

import autogenerated.CymbolBaseVisitor;
import autogenerated.CymbolParser;

public class CymbolGenerationVisitor extends CymbolBaseVisitor<CodeGenerator> {
  FunctionManager functionManager;
  ScopeManager scopeManager;
  int ifsCounter;
  Stack<Integer> ifStack;

  public CymbolGenerationVisitor(FunctionManager functionManager) {
    this.functionManager = functionManager;
    List<String> cur = new LinkedList<String>();
    cur.add(Type.INT);
    this.functionManager.add(new Function("println", cur, Type.VOID));
    this.scopeManager = new ScopeManager();
    this.ifsCounter = 0;
    this.ifStack = new Stack<Integer>();
  }

  @Override 
  public CodeGenerator visitFile(CymbolParser.FileContext ctx) {
    CodeGenerator result = new CodeGenerator();
    result.addCode(".assembly test {}", 0);
    result.addCode(".assembly extern mscorlib {}", 0);
    result.addCode("", 0);
    result.addCode(".method public static void println_func(int32 val) {", 0);
    result.addCode("ldarg.0", 1);
    result.addCode("call void [mscorlib]System.Console::WriteLine(int32)", 1);
    result.addCode("ret", 1);
    result.addCode("}", 0);
    return aggregateResult(result, visitChildren(ctx));
  }

  @Override 
  public CodeGenerator visitVarDecl(CymbolParser.VarDeclContext ctx) {
    this.scopeManager.add(ctx.ID().getText(), Type.convert(ctx.type().getText()));
    Variable now = this.scopeManager.get(ctx.ID().getText());
    CodeGenerator result = null;
    if (ctx.expr() != null) {
      result = ctx.expr().accept(this);
      result.addCode("stloc " + now.getName(), ifStack.size() + 1);
    } else {
      result = new CodeGenerator();
    }
    result.declareVariable(now);
    return result;
  }

  @Override
  public CodeGenerator visitFuncDecl(CymbolParser.FuncDeclContext ctx) {
    String functionName = ctx.ID().getText();
    List<String> paramList = new LinkedList<String>(), namesList = new LinkedList<String>();
    
    CodeGenerator result = new CodeGenerator();

    scopeManager.openScope();

    if(ctx.paramTypeList() != null) {
	    for (CymbolParser.ParamTypeContext param : ctx.paramTypeList().paramType()) {
        String varName = param.ID().getText(), varType = Type.convert(param.type().getText());
        
        scopeManager.add(varName, varType);
        Variable var = scopeManager.get(varName);
        paramList.add(var.getType());
        namesList.add(varName + "_param");

        result.declareVariable(var);
	    }
    }

    // declared function type
    String returnType = Type.convert(ctx.type().getText());

    Function thisFunction = new Function(functionName, paramList, returnType);
    
    CodeGenerator blockResult = ctx.block().accept(this);
    
    
    result.addCode("", 0);

    result.addCode(".method public static " + thisFunction.getCompleteSignature(namesList) + " {", 0);
    
    if (functionName.toLowerCase().equals("main")) {
      result.addCode(".entrypoint", ifStack.size() + 1);
    }
    
    result.addCode(".maxstack 10000", ifStack.size() + 1);

    result.declareVariables(blockResult.getDeclaredVariables());
    if (!result.getDeclaredVariables().isEmpty()) {
      result.addCode(".locals init (" + result.getDeclaredVariablesList() + ")", ifStack.size() + 1);
    }
    
    Iterator<String> it = namesList.iterator();
    while (it.hasNext()) {
      String at = it.next();
      String loc = this.scopeManager.get(at.replace("_param", "")).getName();
      result.addCode("ldarg " + at, 1);
      result.addCode("stloc " + loc, 1);
    }

    result = aggregateResult(result, blockResult);

    result.addCode("ret", 1);
    result.addCode("}", 0);

    result.clearVariables();
    result.setReturnType(Type.VOID);

    scopeManager.closeScope();
    return result;
  }
  
  @Override
  public CodeGenerator visitBlock(CymbolParser.BlockContext ctx) {
    scopeManager.openScope();
    CodeGenerator result = visitChildren(ctx);
    scopeManager.closeScope();
    return result;
  }

  @Override
  public CodeGenerator visitAssignStat(CymbolParser.AssignStatContext ctx) {
    Variable var = this.scopeManager.get(ctx.ID().getText());
    CodeGenerator result = ctx.expr().accept(this);
    result.addCode("stloc " + var.getName(), ifStack.size() + 1);
    return result;
  }

  @Override
  public CodeGenerator visitReturnStat(CymbolParser.ReturnStatContext ctx) {
    CodeGenerator result = null;
    if (ctx.expr() != null) {
      result  = ctx.expr().accept(this);
    } else {
      result = new CodeGenerator();
    }
    result.addCode("ret", ifStack.size() + 1);
    return result;
  }

  @Override
  public CodeGenerator visitIfElseStat(CymbolParser.IfElseStatContext ctx) {
    this.ifsCounter++;
    this.ifStack.push(ifsCounter);
    String trueLabel = "IF_" + ifStack.peek() + "_TRUE",
    falseLabel = "IF_" + ifStack.peek() + "_FALSE",
    endLabel = "IF_" + ifStack.peek() + "_END";

    CodeGenerator result = new CodeGenerator();
    result.addCode("// evaluate if expr", ifStack.size() + 1);
    result = aggregateResult(result, ctx.ifStat().accept(this));
    if (ctx.elseStat() != null) {
      aggregateResult(result, ctx.elseStat().accept(this));
    } else {
      result.addCode(falseLabel + ":", ifStack.size());
      result.addCode("nop", ifStack.size() + 1);
      result.addCode("br " + endLabel, ifStack.size() + 1);
    }
    result.addCode(endLabel + ":", ifStack.size());
    result.setReturnType(Type.VOID);
    ifStack.pop();
    return result;
  }

  @Override
  public CodeGenerator visitIfStat(CymbolParser.IfStatContext ctx) {
    String trueLabel = "IF_" + ifStack.peek() + "_TRUE",
           falseLabel = "IF_" + ifStack.peek() + "_FALSE",
           endLabel = "IF_" + ifStack.peek() + "_END";
    
    Integer aux = ifStack.pop();
    CodeGenerator result = ctx.expr().accept(this);
    result.addCode("brtrue " + trueLabel, ifStack.size() + 1);
    result.addCode("br " + falseLabel, ifStack.size() + 1);

    ifStack.push(aux);
    result.addCode(trueLabel + ":", ifStack.size());
    result = aggregateResult(result, ctx.ifElseExprStat().accept(this));
    result.addCode("br " + endLabel, ifStack.size() + 1);
    result.setReturnType(Type.VOID);
    return result;
  }

  @Override
  public CodeGenerator visitElseStat(CymbolParser.ElseStatContext ctx) {
    String trueLabel = "IF_" + ifStack.peek() + "_TRUE",
           falseLabel = "IF_" + ifStack.peek() + "_FALSE",
           endLabel = "IF_" + ifStack.peek() + "_END";
    CodeGenerator result = new CodeGenerator();
    result.addCode(falseLabel + ":", ifStack.size());
    result = aggregateResult(result, ctx.ifElseExprStat().accept(this));
    result.addCode("br " + endLabel, ifStack.size() + 1);
    return result;
  }

  @Override
  public CodeGenerator visitSignedExpr(CymbolParser.SignedExprContext ctx) {
    CodeGenerator result = ctx.expr().accept(this);
    if (ctx.op.getText().equals("-")) {
      result.addCode("neg", ifStack.size() + 1);
    }
    return result;
  }

  @Override 
  public CodeGenerator visitFunctionCallExpr(CymbolParser.FunctionCallExprContext ctx) {
    String functionName = ctx.ID().getText();
    List<String> paramList = new LinkedList<String>();
    
    CodeGenerator result = new CodeGenerator();

    if(ctx.exprList() != null) {
	    for (CymbolParser.ExprContext expr : ctx.exprList().expr()) {
        CodeGenerator exprResult = expr.accept(this);
        paramList.add(exprResult.getReturnType());
        result = aggregateResult(result, exprResult);
	    }
    }
    
    Function calledFunction = new Function(functionName, paramList, "");
    String returnType = functionManager.get(calledFunction.getSignature()).getReturnType();
    
    calledFunction.setReturnType(returnType);
    result.setReturnType(returnType);

    result.addCode("call " + calledFunction.getCompleteSignature(), ifStack.size() + 1);

    return result;
  }

  @Override
  public CodeGenerator visitMulDivExpr(CymbolParser.MulDivExprContext ctx) {
    CodeGenerator result = aggregateResult(ctx.expr(0).accept(this), ctx.expr(1).accept(this));
    if (ctx.op.getText().equals("*")) {
      result.addCode("mul", ifStack.size() + 1);
    } else {
      result.addCode("div", ifStack.size() + 1);
    }
    return result;
  }

  @Override
  public CodeGenerator visitComparisonExpr(CymbolParser.ComparisonExprContext ctx) {
    CodeGenerator result = aggregateResult(ctx.expr(0).accept(this), ctx.expr(1).accept(this));
    String code = result.getCode();
    String op = ctx.op.getText();
    if ((op.charAt(0) == '<' && op.length() == 1) || ((op.charAt(0) == '>' && op.length() == 2) )) {
      result.addCode("clt", ifStack.size() + 1);
    } else {
      result.addCode("cgt", ifStack.size() + 1);
    }
    if (op.length() > 1) {
      result.addCode("// made the inverse comparison", ifStack.size() + 1);
      result.addCode("// simulate !", ifStack.size() + 1);
      result.addCode("ldc.i4 0", ifStack.size() + 1);
      result.addCode("ceq", ifStack.size() + 1);
    }
    return result;
  }

  @Override
  public CodeGenerator visitEqExpr(CymbolParser.EqExprContext ctx) {
    CodeGenerator result = aggregateResult(ctx.expr(0).accept(this), ctx.expr(1).accept(this));
    String op = ctx.op.getText();
    result.addCode("ceq", ifStack.size() + 1);
    if (op.equals("!=")) {
      result.addCode("// simulate !", ifStack.size() + 1);
      result.addCode("ldc.i4 0", ifStack.size() + 1);
      result.addCode("ceq", ifStack.size() + 1);
    }
    return result;
  }

  @Override
  public CodeGenerator visitNotExpr(CymbolParser.NotExprContext ctx) {
    CodeGenerator result = ctx.expr().accept(this);
    result.addCode("// simulate !", ifStack.size() + 1);
    result.addCode("ldc.i4 0", ifStack.size() + 1);
    result.addCode("ceq", ifStack.size() + 1);
    return result;
  }

  @Override
  public CodeGenerator visitIntExpr(CymbolParser.IntExprContext ctx) {
    String val = ctx.INT().getText();
    CodeGenerator result = new CodeGenerator();
    result.addCode("ldc.i4 " + val, ifStack.size() + 1);
    result.setReturnType(Type.INT);
    return result;
  }

  @Override
  public CodeGenerator visitAddSubExpr(CymbolParser.AddSubExprContext ctx) {
    CodeGenerator result = aggregateResult(ctx.expr(0).accept(this), ctx.expr(1).accept(this));
    if (ctx.op.getText().equals("-")) {
      result.addCode("sub", ifStack.size() + 1);
    } else {
      result.addCode("add", ifStack.size() + 1);
    }
    return result;
  }

  @Override
  public CodeGenerator visitVarIdExpr(CymbolParser.VarIdExprContext ctx) {
    Variable var = this.scopeManager.get(ctx.ID().getText());
    CodeGenerator result = new CodeGenerator();
    result.setReturnType(var.getType());
    result.addCode("ldloc " + var.getName(), ifStack.size() + 1);
    return result;
  }

  @Override
	protected CodeGenerator aggregateResult(CodeGenerator aggregate, CodeGenerator nextResult) {
    if (aggregate == null && nextResult == null) {
      return new CodeGenerator();
    } else if (aggregate == null) {
      return nextResult;
    } else if (nextResult == null) {
    	return aggregate;
    } else {
      CodeGenerator result = aggregate;
      result.aggregate(nextResult);
      return result;
    }
  }
}